# __init__.py# Copyright (C) 2025 ['CHAI CHAIMEE]# Licensed under GNU General Public License. See COPYING.txt for details.import addonHandlerimport apiimport globalPluginHandlerimport globalVarsimport guiimport osimport jsonimport wximport speechimport uiimport reimport sysfrom scriptHandler import scriptfrom logHandler import logimport configaddonHandler.initTranslation()# Path to configuration directory_configPath = globalVars.appArgs.configPath_configDir = os.path.join(_configPath, "invisible")# Constants for word data structureWORD_VALUE = "value"WORD_IS_REGEX = "is_regex"WORD_REPLACEMENT = "replacement"class InvisibleConfig:    """Configuration manager for invisible addon with per-site JSON files"""        def __init__(self):        self.sites = {}  # site_id: {"display_name": "", "url": "", "mode": "single"/"whole", "words": []}        self._ensure_config_dir()        self._load_all_sites()        def _ensure_config_dir(self):        """Create configuration directory if it doesn't exist"""        if not os.path.exists(_configDir):            os.makedirs(_configDir)        def _safe_filename(self, name):        """Convert display name to safe filename"""        # Replace invalid characters with underscore        name = re.sub(r'[\\/*?:"<>|]', "_", name)        # Limit length to avoid filesystem issues        if len(name) > 100:            name = name[:100]        return name + ".json"        def _load_all_sites(self):        """Load all site configurations from JSON files"""        self.sites = {}                try:            if os.path.exists(_configDir):                for filename in os.listdir(_configDir):                    if filename.endswith('.json'):                        filepath = os.path.join(_configDir, filename)                        try:                            with open(filepath, 'r', encoding='utf-8') as f:                                site_data = json.load(f)                                                                # Ensure required fields exist                                if "url" in site_data and "display_name" in site_data:                                    # Migration: convert old word structure if needed                                    words = site_data.get("words", [])                                    for i, word_data in enumerate(words):                                        if isinstance(word_data, str):                                            words[i] = {WORD_VALUE: word_data, WORD_IS_REGEX: False, WORD_REPLACEMENT: ""}                                        elif isinstance(word_data, dict):                                            # Ensure all required fields exist                                            if WORD_REPLACEMENT not in word_data:                                                word_data[WORD_REPLACEMENT] = ""                                                                        # Migration: ensure mode field exists (default to "single")                                    if "mode" not in site_data:                                        site_data["mode"] = "single"                                                                        # Use display_name as key for easier management                                    site_id = site_data["display_name"]                                    self.sites[site_id] = site_data                        except Exception as e:                            log.error(f"Error loading site config {filename}: {e}")        except Exception as e:            log.error(f"Error reading config directory: {e}")        def _save_site(self, site_id):        """Save individual site configuration to JSON file"""        if site_id in self.sites:            site_data = self.sites[site_id]            filename = self._safe_filename(site_id)            filepath = os.path.join(_configDir, filename)                        try:                with open(filepath, 'w', encoding='utf-8') as f:                    json.dump(site_data, f, ensure_ascii=False, indent=2)                return True            except Exception as e:                log.error(f"Error saving site config {site_id}: {e}")                return False        return False        def _delete_site_file(self, site_id):        """Delete site configuration file"""        if site_id in self.sites:            filename = self._safe_filename(site_id)            filepath = os.path.join(_configDir, filename)            try:                if os.path.exists(filepath):                    os.remove(filepath)                    return True            except Exception as e:                log.error(f"Error deleting site config {site_id}: {e}")        return False        def get_site_by_url(self, url):        """Get site data by matching URL (considering mode)"""        if not url:            return None                # Parse domain from URL        domain = self._extract_domain(url)                for site_data in self.sites.values():            site_url = site_data.get("url", "")            mode = site_data.get("mode", "single")                        if mode == "single" and url == site_url:                return site_data            elif mode == "whole" and domain and domain == self._extract_domain(site_url):                return site_data                return None        def _extract_domain(self, url):        """Extract domain from URL"""        try:            # Remove protocol            if "://" in url:                url = url.split("://", 1)[1]                        # Remove path and query parameters            domain = url.split("/")[0]                        # Remove port if present            domain = domain.split(":")[0]                        return domain.lower()        except:            return None        def get_site_by_id(self, site_id):        """Get site data by site ID (display_name)"""        return self.sites.get(site_id)        def add_site(self, url, display_name, mode="single"):        """Add a new site configuration"""        if not url or not display_name:            return False                # Check for duplicate display name        if display_name in self.sites:            # Append number to make it unique            counter = 1            while f"{display_name} ({counter})" in self.sites:                counter += 1            display_name = f"{display_name} ({counter})"                site_data = {            "url": url,            "display_name": display_name,            "mode": mode,            "words": []        }                self.sites[display_name] = site_data        return self._save_site(display_name)        def update_site(self, old_site_id, new_display_name=None, new_url=None, new_mode=None):        """Update site configuration"""        if old_site_id not in self.sites:            return False                site_data = self.sites[old_site_id]        changed = False                if new_display_name and new_display_name != old_site_id:            # Check if new display name already exists            if new_display_name in self.sites and new_display_name != old_site_id:                return False                        # Update display name (key in dictionary)            self.sites[new_display_name] = site_data            del self.sites[old_site_id]            site_data["display_name"] = new_display_name            old_site_id = new_display_name            changed = True                if new_url and new_url != site_data.get("url"):            site_data["url"] = new_url            changed = True                if new_mode and new_mode != site_data.get("mode"):            site_data["mode"] = new_mode            changed = True                if changed:            # Delete old file if display name changed            if new_display_name and new_display_name != old_site_id:                self._delete_site_file(old_site_id)            return self._save_site(old_site_id)                return True        def remove_site(self, site_id):        """Remove site configuration"""        if site_id in self.sites:            # Delete file first            if self._delete_site_file(site_id):                del self.sites[site_id]                return True        return False        def _get_display_word(self, word_data):        """Helper to create display string for word in listbox"""        value = word_data.get(WORD_VALUE, "")        is_regex = word_data.get(WORD_IS_REGEX, False)        replacement = word_data.get(WORD_REPLACEMENT, "")                if is_regex:            if replacement:                return f"[{_('Regex')}] {value} → {replacement}"            else:                return f"[{_('Regex')}] {value}"        else:            if replacement:                return f"{value} → {replacement}"            else:                return value        def get_words_for_site(self, site_id):        """Get the list of word data for a site"""        site_data = self.get_site_by_id(site_id)        if site_data:            return site_data.get("words", [])        return []        def add_word(self, site_id, word, is_regex, replacement=""):        """Add a word (with regex status) to skip for a site"""        if site_id in self.sites:            new_word_data = {WORD_VALUE: word, WORD_IS_REGEX: is_regex, WORD_REPLACEMENT: replacement}            words_list = self.sites[site_id]["words"]                        # Check for duplicates based on value and is_regex status            if not any(d[WORD_VALUE] == word and d[WORD_IS_REGEX] == is_regex for d in words_list):                words_list.append(new_word_data)                # Sort by value (case-insensitive)                words_list.sort(key=lambda x: x[WORD_VALUE].lower())                return self._save_site(site_id)        return False        def update_word(self, site_id, old_word_data, new_word, new_is_regex, new_replacement=""):        """Update an existing word data in the skip list for a site"""        if site_id in self.sites:            words_list = self.sites[site_id]["words"]                        # Find the index of the old word data            try:                index = -1                for i, d in enumerate(words_list):                    if d[WORD_VALUE] == old_word_data[WORD_VALUE] and d[WORD_IS_REGEX] == old_word_data[WORD_IS_REGEX]:                        index = i                        break                                if index != -1:                    # Check if the new word/regex combo already exists elsewhere                    new_word_data = {WORD_VALUE: new_word, WORD_IS_REGEX: new_is_regex, WORD_REPLACEMENT: new_replacement}                                        if any(d[WORD_VALUE] == new_word and d[WORD_IS_REGEX] == new_is_regex and i != index                            for i, d in enumerate(words_list)):                        # If duplicate exists, remove the old one                        words_list.pop(index)                    else:                        # Update the existing element                        words_list[index] = new_word_data                                        # Sort after update/removal                    words_list.sort(key=lambda x: x[WORD_VALUE].lower())                    return self._save_site(site_id)            except Exception as e:                log.error(f"Error updating word: {e}")        return False        def remove_word(self, site_id, word_data):        """Remove a word data from skip list for a site"""        if site_id in self.sites:            words_list = self.sites[site_id]["words"]            try:                # Remove by exact match                words_list.remove(word_data)                return self._save_site(site_id)            except ValueError:                log.error("Invisible Config: Word data not found for removal.")        return False        def get_all_sites(self):        """Get all sites with their display names"""        result = []        for site_id, site_data in self.sites.items():            result.append((site_id, site_data.get("display_name", site_id)))                # Sort by display name (case-insensitive)        result.sort(key=lambda x: x[1].lower())        return resultclass InvisibleDialog(wx.Dialog):    """Main dialog for managing invisible settings"""        def __init__(self, parent, current_url, config):        super(InvisibleDialog, self).__init__(            parent,             title=_("Invisible Settings"),            style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER        )        self.current_url = current_url        self.config = config        self.current_site_id = None        self.editing_word_data = None                # Check if current URL matches any existing site        existing_site = self.config.get_site_by_url(current_url)        if existing_site:            self.current_site_id = existing_site["display_name"]            self.site_data = existing_site        else:            # Create default display name from URL            display_name = self._create_display_name(current_url)            self.site_data = {                "url": current_url,                "display_name": display_name,                "mode": "single",                "words": []            }            self.current_site_id = display_name                # Load the list of word dictionaries        self.words_data = self.config.get_words_for_site(self.current_site_id)                self.initUI()        self.Centre()                # Set focus to site list        wx.CallAfter(self.siteList.SetFocus)        def _create_display_name(self, url):        """Create display name from URL"""        try:            # Extract domain            domain = self.config._extract_domain(url)            if domain:                # Remove www. if present                if domain.startswith("www."):                    domain = domain[4:]                return domain.capitalize()        except:            pass                # Fallback: use URL with max 30 chars        if len(url) > 30:            return url[:27] + "..."        return url        def initUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)                # Site List Section        siteBox = wx.StaticBoxSizer(wx.VERTICAL, self, label=_("Site List"))                # Site list with all sites        self.siteList = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 100))        self.load_site_list()        siteBox.Add(self.siteList, 1, wx.EXPAND | wx.ALL, 5)                # Site Settings section        siteSettingsLabel = wx.StaticText(self, label=_("Site Settings:"))        siteBox.Add(siteSettingsLabel, 0, wx.ALL, 5)                # Display name input        nameSizer = wx.BoxSizer(wx.HORIZONTAL)        nameSizer.Add(wx.StaticText(self, label=_("Display name:")), 0, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)        self.nameCtrl = wx.TextCtrl(self, value=self.site_data.get("display_name", ""))        nameSizer.Add(self.nameCtrl, 1, wx.EXPAND)        siteBox.Add(nameSizer, 0, wx.EXPAND | wx.ALL, 5)                # URL input        urlSizer = wx.BoxSizer(wx.HORIZONTAL)        urlSizer.Add(wx.StaticText(self, label=_("URL:")), 0, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)        self.urlCtrl = wx.TextCtrl(self, value=self.site_data.get("url", self.current_url))        urlSizer.Add(self.urlCtrl, 1, wx.EXPAND)        siteBox.Add(urlSizer, 0, wx.EXPAND | wx.ALL, 5)                # Mode selection (Single page / Whole website)        modeSizer = wx.BoxSizer(wx.HORIZONTAL)        modeSizer.Add(wx.StaticText(self, label=_("Apply to:")), 0, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)        self.modeCombo = wx.ComboBox(self, choices=[_("Single page only"), _("Whole website (domain)")],                                      style=wx.CB_READONLY)                # Set current mode        current_mode = self.site_data.get("mode", "single")        if current_mode == "whole":            self.modeCombo.SetSelection(1)        else:            self.modeCombo.SetSelection(0)                modeSizer.Add(self.modeCombo, 1, wx.EXPAND)        siteBox.Add(modeSizer, 0, wx.EXPAND | wx.ALL, 5)                # Site buttons - only Add New Site remains        siteBtnSizer = wx.BoxSizer(wx.HORIZONTAL)        self.addSiteBtn = wx.Button(self, label=_("Add New Site"))                siteBtnSizer.Add(self.addSiteBtn, 0, wx.ALL, 5)                siteBox.Add(siteBtnSizer, 0, wx.ALIGN_CENTER)                mainSizer.Add(siteBox, 1, wx.EXPAND | wx.ALL, 5)                # Entries Section         entriesBox = wx.StaticBoxSizer(wx.VERTICAL, self, label=_("Entries"))                # Entries list        self.wordsList = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 150))        self.update_words_list()        entriesBox.Add(self.wordsList, 1, wx.EXPAND | wx.ALL, 5)                # Pattern input section         patternLabel = wx.StaticText(self, label=_("Pattern:"))        entriesBox.Add(patternLabel, 0, wx.ALL, 5)                self.wordCtrl = wx.TextCtrl(self)        entriesBox.Add(self.wordCtrl, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 5)                # Replacement field (always visible)        replacementSizer = wx.BoxSizer(wx.HORIZONTAL)        self.replacementLabel = wx.StaticText(self, label=_("Replacement:"))        self.replacementCtrl = wx.TextCtrl(self)                replacementSizer.Add(self.replacementLabel, 0, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 5)        replacementSizer.Add(self.replacementCtrl, 1, wx.EXPAND)                entriesBox.Add(replacementSizer, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 5)                # Regex Checkbox (moved below Replacement)        self.regexCheck = wx.CheckBox(self, label=_("Use as regular expression"))        self.regexCheck.SetValue(False)        entriesBox.Add(self.regexCheck, 0, wx.LEFT | wx.RIGHT | wx.TOP, 5)                # Word buttons - keep all buttons        wordBtnSizer = wx.BoxSizer(wx.VERTICAL)                self.addUpdateWordBtn = wx.Button(self, label=_("&Add"))        self.editWordBtn = wx.Button(self, label=_("&Edit"))        self.removeWordBtn = wx.Button(self, label=_("&Remove"))        self.cancelEditBtn = wx.Button(self, label=_("&Cancel"))        self.cancelEditBtn.Hide()                wordBtnSizer.Add(self.addUpdateWordBtn, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 5)        wordBtnSizer.Add(self.editWordBtn, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 5)        wordBtnSizer.Add(self.removeWordBtn, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 5)        wordBtnSizer.Add(self.cancelEditBtn, 0, wx.EXPAND | wx.LEFT | wx.RIGHT, 5)                entriesBox.Add(wordBtnSizer, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.TOP | wx.BOTTOM, 5)                mainSizer.Add(entriesBox, 2, wx.EXPAND | wx.ALL, 5)                # Close button        btnSizer = wx.BoxSizer(wx.HORIZONTAL)        self.okBtn = wx.Button(self, wx.ID_OK, label=_("&OK"))        self.closeBtn = wx.Button(self, wx.ID_CLOSE, label=_("&Close"))                btnSizer.Add(self.okBtn, 0, wx.ALL, 5)        btnSizer.Add(self.closeBtn, 0, wx.ALL, 5)        mainSizer.Add(btnSizer, 0, wx.ALIGN_CENTER | wx.ALL, 10)                self.SetSizer(mainSizer)        self.SetSize(600, 780)                # Bind events        self.Bind(wx.EVT_LISTBOX, self.onSiteSelect, self.siteList)        self.Bind(wx.EVT_BUTTON, self.onAddSite, self.addSiteBtn)        self.Bind(wx.EVT_BUTTON, self.onAddUpdateWord, self.addUpdateWordBtn)        self.Bind(wx.EVT_BUTTON, self.onEditWord, self.editWordBtn)        self.Bind(wx.EVT_BUTTON, self.onRemoveWord, self.removeWordBtn)        self.Bind(wx.EVT_BUTTON, self.onCancelEdit, self.cancelEditBtn)        self.Bind(wx.EVT_BUTTON, self.onOk, self.okBtn)        self.Bind(wx.EVT_BUTTON, self.onClose, self.closeBtn)        self.Bind(wx.EVT_CLOSE, self.onClose)        self.Bind(wx.EVT_TEXT, self.onWordTextChange, self.wordCtrl)        self.Bind(wx.EVT_CHECKBOX, self.onRegexCheck, self.regexCheck)        self.Bind(wx.EVT_LISTBOX, self.onWordListSelect, self.wordsList)                # Context menu for site list        self.siteList.Bind(wx.EVT_CONTEXT_MENU, self.onSiteListContextMenu)                # Context menu for words list        self.wordsList.Bind(wx.EVT_CONTEXT_MENU, self.onWordsListContextMenu)                # Set escape key to close        self.SetEscapeId(self.closeBtn.GetId())                # Select current site in list        self.select_current_site()        self.update_button_states()        def onSiteListContextMenu(self, event):        """Show context menu for site list"""        if self.siteList.GetSelection() == wx.NOT_FOUND:            return                menu = wx.Menu()                edit_item = menu.Append(wx.ID_EDIT, _("&Edit Site"))        remove_item = menu.Append(wx.ID_DELETE, _("&Remove Site"))                self.Bind(wx.EVT_MENU, self.onContextEditSite, edit_item)        self.Bind(wx.EVT_MENU, self.onContextRemoveSite, remove_item)                self.PopupMenu(menu)        menu.Destroy()        def onWordsListContextMenu(self, event):        """Show context menu for words list"""        if self.wordsList.GetSelection() == wx.NOT_FOUND:            return                menu = wx.Menu()                edit_item = menu.Append(wx.ID_EDIT, _("&Edit Word"))        remove_item = menu.Append(wx.ID_DELETE, _("&Remove Word"))                self.Bind(wx.EVT_MENU, self.onContextEditWord, edit_item)        self.Bind(wx.EVT_MENU, self.onContextRemoveWord, remove_item)                self.PopupMenu(menu)        menu.Destroy()        def onContextEditSite(self, event):        """Handle Edit Site from context menu"""        self.onEditSite(None)        def onContextRemoveSite(self, event):        """Handle Remove Site from context menu"""        self.onRemoveSite(None)        def onContextEditWord(self, event):        """Handle Edit Word from context menu"""        self.onEditWord(None)        def onContextRemoveWord(self, event):        """Handle Remove Word from context menu"""        self.onRemoveWord(None)        def load_site_list(self):        """Load all sites into list"""        sites = self.config.get_all_sites()        self.siteList.Clear()        for site_id, display_name in sites:            self.siteList.Append(display_name)        def select_current_site(self):        """Select current site in list"""        sites = self.config.get_all_sites()        for i, (site_id, display_name) in enumerate(sites):            if site_id == self.current_site_id:                self.siteList.SetSelection(i)                break        else:            # If not found, add it to the list            display_name = self.site_data.get("display_name", self.current_site_id)            self.siteList.Append(display_name)            self.siteList.SetSelection(self.siteList.GetCount() - 1)        def update_words_list(self):        """Update words list"""        self.wordsList.Clear()                # Store display names and map index to actual word data        self.word_data_map = {}        for i, word_data in enumerate(self.words_data):            display_name = self.config._get_display_word(word_data)            self.wordsList.Append(display_name)            self.word_data_map[i] = word_data                if self.wordsList.GetCount() > 0:            self.wordsList.SetSelection(0)        def update_button_states(self):        """Update button states based on selections and editing status"""        has_site_selection = self.siteList.GetSelection() != wx.NOT_FOUND        has_word_selection = self.wordsList.GetSelection() != wx.NOT_FOUND        current_word_value = self.wordCtrl.GetValue().strip()        has_word_text = bool(current_word_value)                # Check if we're in edit mode        if self.editing_word_data:            self.addUpdateWordBtn.SetLabel(_("&Update"))            self.addUpdateWordBtn.Enable(has_word_text)            self.editWordBtn.Enable(False)            self.removeWordBtn.Enable(False)            self.cancelEditBtn.Show()        else:            self.addUpdateWordBtn.SetLabel(_("&Add"))            self.addUpdateWordBtn.Enable(has_word_text)            self.editWordBtn.Enable(has_word_selection)            self.removeWordBtn.Enable(has_word_selection)            self.cancelEditBtn.Hide()                self.Layout()        def onWordTextChange(self, event):        """Handle change in word input field"""        self.update_button_states()        event.Skip()        def onRegexCheck(self, event):        """Handle regex checkbox change"""        self.update_button_states()        event.Skip()        def onWordListSelect(self, event):        """Handle word selection in list"""        # No confirmation dialog when selecting words        if self.editing_word_data:            # If we're editing and select a different word, cancel edit mode            self.cancel_edit_mode()                self.update_button_states()        event.Skip()        def cancel_edit_mode(self):        """Cancel edit mode and clear fields"""        self.editing_word_data = None        self.wordCtrl.Clear()        self.regexCheck.SetValue(False)        self.replacementCtrl.Clear()        self.update_button_states()        def onSiteSelect(self, event):        """Handle site selection"""        # Cancel any word editing when switching sites        if self.editing_word_data:            self.cancel_edit_mode()                index = self.siteList.GetSelection()        if index == wx.NOT_FOUND:            return                # Get actual site from display name        sites = self.config.get_all_sites()        if index < len(sites):            self.current_site_id = sites[index][0]                        # Get site data            site_data = self.config.get_site_by_id(self.current_site_id)            if site_data:                self.site_data = site_data                self.words_data = self.config.get_words_for_site(self.current_site_id)                                # Update UI                self.nameCtrl.SetValue(site_data.get("display_name", ""))                self.urlCtrl.SetValue(site_data.get("url", ""))                                # Set mode in combo box                mode = site_data.get("mode", "single")                if mode == "whole":                    self.modeCombo.SetSelection(1)                else:                    self.modeCombo.SetSelection(0)                                self.update_words_list()                self.cancel_edit_mode()                self.update_button_states()        def onAddSite(self, event):        """Add a new site"""        # Use current URL as default        default_name = self._create_display_name(self.current_url)                dlg = wx.TextEntryDialog(            self,            _("Enter a name for the new site:"),            _("Add New Site"),            default_name        )                if dlg.ShowModal() == wx.ID_OK:            display_name = dlg.GetValue().strip()            if display_name:                # Get mode from current selection                mode = "whole" if self.modeCombo.GetSelection() == 1 else "single"                                if self.config.add_site(self.current_url, display_name, mode):                    # Refresh site list                    self.load_site_list()                                        # Find and select the new site                    sites = self.config.get_all_sites()                    for i, (site_id, name) in enumerate(sites):                        if site_id == display_name:                            self.siteList.SetSelection(i)                            self.onSiteSelect(None)                            break                                        ui.message(_("Site added: {}").format(display_name))                else:                    ui.message(_("Failed to add site"))                dlg.Destroy()        def onEditSite(self, event):        """Update site settings from context menu"""        new_display_name = self.nameCtrl.GetValue().strip()        new_url = self.urlCtrl.GetValue().strip()        new_mode = "whole" if self.modeCombo.GetSelection() == 1 else "single"                if not new_display_name:            ui.message(_("Display name cannot be empty"))            return                if not new_url:            ui.message(_("URL cannot be empty"))            return                if self.config.update_site(self.current_site_id, new_display_name, new_url, new_mode):            # Update current site ID if display name changed            if new_display_name != self.current_site_id:                self.current_site_id = new_display_name                        # Refresh site list            self.load_site_list()            self.select_current_site()            ui.message(_("Site settings updated"))        else:            ui.message(_("Failed to update site settings. Display name might already exist."))        def onRemoveSite(self, event):        """Remove selected site"""        sites = self.config.get_all_sites()        for site_id, display_name in sites:            if site_id == self.current_site_id:                # Confirm removal                dlg = wx.MessageDialog(                    self,                    _("Are you sure you want to remove '{}'?").format(display_name),                    _("Confirm Removal"),                    wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION                )                                if dlg.ShowModal() == wx.ID_YES:                    if self.config.remove_site(site_id):                        # Refresh site list                        self.load_site_list()                        if self.siteList.GetCount() > 0:                            self.siteList.SetSelection(0)                            self.onSiteSelect(None)                        else:                            # Create default for current URL                            self.current_site_id = None                            display_name = self._create_display_name(self.current_url)                            self.site_data = {                                "url": self.current_url,                                "display_name": display_name,                                "mode": "single",                                "words": []                            }                            self.current_site_id = display_name                            self.nameCtrl.SetValue(display_name)                            self.urlCtrl.SetValue(self.current_url)                            self.modeCombo.SetSelection(0)                            self.words_data = []                            self.update_words_list()                                                ui.message(_("Site removed: {}").format(display_name))                    else:                        ui.message(_("Failed to remove site"))                dlg.Destroy()                break        def onAddUpdateWord(self, event):        """Add new word or update existing word"""        word = self.wordCtrl.GetValue().strip()        is_regex = self.regexCheck.GetValue()        replacement = self.replacementCtrl.GetValue().strip()                if not word:            ui.message(_("Please enter a pattern"))            return                if not self.current_site_id:            ui.message(_("No site selected"))            return                # Validate regex if required        if is_regex:            try:                re.compile(word)            except re.error:                ui.message(_("Invalid Regular Expression syntax"))                return                # Handle update        if self.editing_word_data:            old_word_data = self.editing_word_data            old_word_value = old_word_data[WORD_VALUE]            old_is_regex = old_word_data[WORD_IS_REGEX]            old_replacement = old_word_data.get(WORD_REPLACEMENT, "")                        # Check if the new word/regex combo already exists elsewhere            new_word_data = {WORD_VALUE: word, WORD_IS_REGEX: is_regex, WORD_REPLACEMENT: replacement}            if any(d[WORD_VALUE] == word and d[WORD_IS_REGEX] == is_regex and d != old_word_data                   for d in self.words_data):                ui.message(_("This pattern/regex combination is already in the list"))                return                        if self.config.update_word(self.current_site_id, old_word_data, word, is_regex, replacement):                self.words_data = self.config.get_words_for_site(self.current_site_id)                self.update_words_list()                self.cancel_edit_mode()                ui.message(_("Entry updated successfully"))                # Set focus to words list after update                wx.CallAfter(self.wordsList.SetFocus)            else:                ui.message(_("Failed to update entry"))                # Handle Add        else:            # Check for duplicates            if any(d[WORD_VALUE] == word and d[WORD_IS_REGEX] == is_regex for d in self.words_data):                ui.message(_("This pattern/regex combination is already in the list"))                return                        if self.config.add_word(self.current_site_id, word, is_regex, replacement):                self.words_data = self.config.get_words_for_site(self.current_site_id)                self.update_words_list()                self.wordCtrl.Clear()                self.regexCheck.SetValue(False)                self.replacementCtrl.Clear()                self.update_button_states()                ui.message(_("Entry added successfully"))                # Keep focus on wordCtrl for adding more words                wx.CallAfter(self.wordCtrl.SetFocus)            else:                ui.message(_("Failed to add entry"))        def onEditWord(self, event):        """Prepare to edit selected word"""        index = self.wordsList.GetSelection()        if index == wx.NOT_FOUND:            return                word_data = self.word_data_map.get(index)        if not word_data:            return                self.wordCtrl.SetValue(word_data[WORD_VALUE])        self.regexCheck.SetValue(word_data.get(WORD_IS_REGEX, False))        self.replacementCtrl.SetValue(word_data.get(WORD_REPLACEMENT, ""))                self.wordCtrl.SetFocus()                self.editing_word_data = word_data        self.update_button_states()        ui.message(_("Editing entry: {}").format(self.config._get_display_word(word_data)))        def onCancelEdit(self, event):        """Cancel edit mode"""        self.cancel_edit_mode()        ui.message(_("Edit cancelled"))        # Set focus back to words list        wx.CallAfter(self.wordsList.SetFocus)        def onRemoveWord(self, event):        """Remove selected word"""        index = self.wordsList.GetSelection()        if index == wx.NOT_FOUND:            return                word_data = self.word_data_map.get(index)        if not word_data:            return                display_name = self.wordsList.GetString(index)                dlg = wx.MessageDialog(            self,            _("Are you sure you want to remove '{}'?").format(display_name),            _("Confirm Removal"),            wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION        )                if dlg.ShowModal() == wx.ID_YES:            if self.config.remove_word(self.current_site_id, word_data):                self.words_data = self.config.get_words_for_site(self.current_site_id)                self.update_words_list()                self.cancel_edit_mode()                ui.message(_("Entry removed: {}").format(display_name))                # Set focus back to words list                wx.CallAfter(self.wordsList.SetFocus)            else:                ui.message(_("Failed to remove entry"))                dlg.Destroy()        def onOk(self, event):        """Handle OK button"""        self.EndModal(wx.ID_OK)        def onClose(self, event):        """Handle close button"""        self.EndModal(wx.ID_CANCEL)class GlobalPlugin(globalPluginHandler.GlobalPlugin):    scriptCategory = _("Invisible")        def __init__(self):        super(GlobalPlugin, self).__init__()        self.config = InvisibleConfig()                # Store the original processText function        if hasattr(speech, "speech"):            self.original_process_text = speech.speech.processText            speech.speech.processText = self.process_text        else:            self.original_process_text = speech.processText            speech.processText = self.process_text        def terminate(self):        """Clean up when addon is terminated"""        if hasattr(speech, "speech"):            speech.speech.processText = self.original_process_text        else:            speech.processText = self.original_process_text        def process_text(self, locale, text, symbolLevel=None, **kwargs):        """Process text to skip words for current URL"""        # Get current URL        current_url = self.get_current_url()                # If we have a site for this URL, process its words        if current_url:            site_data = self.config.get_site_by_url(current_url)            if site_data:                words_data = site_data.get("words", [])                                # Separate literal words and regex patterns                literal_entries = []  # tuple (value, replacement)                regex_patterns = []   # tuple (pattern, replacement)                                for word_data in words_data:                    value = word_data.get(WORD_VALUE)                    is_regex = word_data.get(WORD_IS_REGEX, False)                    replacement = word_data.get(WORD_REPLACEMENT, "")                                        if value:                        if is_regex:                            # Store pattern and replacement for regex                            regex_patterns.append((value, replacement))                        else:                            literal_entries.append((value, replacement))                                # Process literal words first (longest first)                literal_entries_sorted = sorted(literal_entries, key=lambda x: len(x[0]), reverse=True)                for word, replacement in literal_entries_sorted:                    text = text.replace(word, replacement)                                # Process regex patterns with replacements                for pattern, replacement in regex_patterns:                    try:                        text = re.sub(pattern, replacement, text)                    except re.error as e:                        log.error(f"Invalid regex pattern skipped: '{pattern}'. Error: {e}")                # Call original function        return self.original_process_text(locale, text, symbolLevel, **kwargs)        def get_current_url(self):        """Get current URL from focused browser"""        try:            focus = api.getFocusObject()                        # Try to get URL from different browser types            if hasattr(focus, 'treeInterceptor') and focus.treeInterceptor is not None:                tree_interceptor = focus.treeInterceptor                if hasattr(tree_interceptor, 'documentConstantIdentifier'):                    url = tree_interceptor.documentConstantIdentifier                    if url and (url.startswith('http') or url.startswith('file')):                        return url                        # Try to get URL from document object            if hasattr(focus, 'IAccessibleObject'):                try:                    url = focus.IAccessibleObject.accValue(0)                    if url and (url.startswith('http') or url.startswith('file')):                        return url                except:                    pass                        # For UIA objects            if hasattr(focus, 'UIAElement'):                try:                    url = focus.UIAElement.CurrentValue                    if url and (url.startswith('http') or url.startswith('file')):                        return url                except:                    pass                        # Try to get URL from window title            if hasattr(focus, 'windowText'):                window_text = focus.windowText                url_pattern = r'https?://[^\s]+|file:///[^\s]+'                match = re.search(url_pattern, window_text)                if match:                    return match.group(0)                        return None                    except Exception as e:            log.debug(f"Error getting current URL: {e}")            return None        @script(        description=_("Open invisible settings"),        gesture="kb:NVDA+shift+W",        category=_("Invisible")    )    def script_open_settings(self, gesture):        """Open settings dialog"""        current_url = self.get_current_url()                if not current_url:            ui.message(_("Cannot capture URL. Make sure you are in a browser."))            return                # Open settings dialog        try:            gui.mainFrame.popupSettingsDialog(InvisibleDialog, current_url, self.config)        except AttributeError:            gui.mainFrame._popupSettingsDialog(InvisibleDialog, current_url, self.config)